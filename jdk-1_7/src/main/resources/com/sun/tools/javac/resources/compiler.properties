#
# Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#
compiler.err.abstract.cant.be.accessed.directly=abstract {0} {1} in {2} cannot be accessed directly
compiler.err.abstract.cant.be.instantiated={0} is abstract; cannot be instantiated
compiler.err.abstract.meth.cant.have.body=abstract methods cannot have a body
compiler.err.already.annotated={0} {1} has already been annotated
compiler.err.already.defined={0} {1} is already defined in {2} {3}
compiler.err.already.defined.in.clinit={0} {1} is already defined in {2} of {3} {4}
compiler.err.already.defined.single.import={0} is already defined in a single-type import
compiler.err.already.defined.static.single.import={0} is already defined in a static single-type import
compiler.err.already.defined.this.unit={0} is already defined in this compilation unit
compiler.err.annotation.missing.default.value=annotation {0} is missing value for the attribute {1}
compiler.err.annotation.missing.default.value.1=annotation {0} is missing values for attributes {1}
compiler.err.annotation.not.valid.for.type=annotation not valid for a value of type {0}
compiler.err.annotation.type.not.applicable=annotation type not applicable to this kind of declaration
compiler.err.annotation.value.must.be.annotation=annotation value must be an annotation
compiler.err.annotation.value.must.be.class.literal=annotation value must be a class literal
compiler.err.annotation.value.must.be.name.value=annotation values must be of the form ''name=value''
compiler.err.annotation.value.not.allowable.type=annotation value not of an allowable type
compiler.err.annotations.not.supported.in.source=annotations are not supported in -source {0}\n(use -source 5 or higher to enable annotations)
compiler.err.anon.class.impl.intf.no.args=anonymous class implements interface; cannot have arguments
compiler.err.anon.class.impl.intf.no.qual.for.new=anonymous class implements interface; cannot have qualifier for new
compiler.err.anon.class.impl.intf.no.typeargs=anonymous class implements interface; cannot have type arguments
compiler.err.array.and.varargs=cannot declare both {0} and {1} in {2}
compiler.err.array.dimension.missing=array dimension missing
compiler.err.array.req.but.found=array required, but {0} found
compiler.err.assert.as.identifier=as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n(use -source 1.3 or lower to use ''assert'' as an identifier)
compiler.err.assignment.from.super-bound=assigning from wildcard {0}
compiler.err.assignment.to.extends-bound=assigning to wildcard {0}
compiler.err.attribute.value.must.be.constant=attribute value must be constant
compiler.err.break.outside.switch.loop=break outside switch or loop
compiler.err.call.must.be.first.stmt.in.ctor=call to {0} must be first statement in constructor
compiler.err.call.to.super.not.allowed.in.enum.ctor=call to super not allowed in enum constructor
compiler.err.cannot.create.array.with.diamond=cannot create array with ''<>''
compiler.err.cannot.create.array.with.type.arguments=cannot create array with type arguments
compiler.err.cant.access=cannot access {0}\n{1}
compiler.err.cant.apply.diamond=cannot infer type arguments for {0}
compiler.err.cant.apply.diamond.1=cannot infer type arguments for {0};\nreason: {1}
compiler.err.cant.apply.symbol={0} {1} in {4} {5} cannot be applied to given types\nrequired: {2}\nfound: {3}
compiler.err.cant.apply.symbol.1={0} {1} in {4} {5} cannot be applied to given types;\nrequired: {2}\nfound: {3}\nreason: {6}
compiler.err.cant.apply.symbols=no suitable {0} found for {1}({2})
compiler.err.cant.assign.val.to.final.var=cannot assign a value to final variable {0}
compiler.err.cant.deref={0} cannot be dereferenced
compiler.err.cant.extend.intf.annotation=''extends'' not allowed for @interfaces
compiler.err.cant.inherit.diff.arg={0} cannot be inherited with different arguments: <{1}> and <{2}>
compiler.err.cant.inherit.from.final=cannot inherit from final {0}
compiler.err.cant.read.file=cannot read: {0}
compiler.err.cant.ref.before.ctor.called=cannot reference {0} before supertype constructor has been called
compiler.err.cant.resolve=cannot find symbol\nsymbol: {0} {1}
compiler.err.cant.resolve.args=cannot find symbol\nsymbol: {0} {1}({3})
compiler.err.cant.resolve.args.params=cannot find symbol\nsymbol: {0} <{2}>{1}({3})
compiler.err.cant.resolve.location=cannot find symbol\nsymbol:   {0} {1}\nlocation: {4}
compiler.err.cant.resolve.location.args=cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}
compiler.err.cant.resolve.location.args.params=cannot find symbol\nsymbol:   {0} <{2}>{1}({3})\nlocation: {4}
compiler.err.cant.ret.val.from.meth.decl.void=cannot return a value from method whose result type is void
compiler.err.cant.select.static.class.from.param.type=cannot select a static class from a parameterized type
compiler.err.catch.without.try=''catch'' without ''try''
compiler.err.clash.with.pkg.of.same.name={0} {1} clashes with package of same name
compiler.err.class.cant.write=error while writing {0}: {1}
compiler.err.class.public.should.be.in.file=class {0} is public, should be declared in a file named {0}.java
compiler.err.concrete.inheritance.conflict=methods {0} from {1} and {2} from {3} are inherited with the same signature
compiler.err.const.expr.req=constant expression required
compiler.err.cont.outside.loop=continue outside of loop
compiler.err.cyclic.annotation.element=cyclic annotation element type
compiler.err.cyclic.inheritance=cyclic inheritance involving {0}
compiler.err.default.allowed.in.intf.annotation.member=default value only allowed in an @interface member
compiler.err.diamond.not.supported.in.source=diamond operator is not supported in -source {0}\n(use -source 7 or higher to enable diamond operator)
compiler.err.does.not.override.abstract={0} is not abstract and does not override abstract method {1} in {2}
compiler.err.doesnt.exist=package {0} does not exist
compiler.err.dot.class.expected=''.class'' expected
compiler.err.duplicate.annotation=duplicate annotation
compiler.err.duplicate.annotation.member.value=duplicate annotation member value {0} in {1}
compiler.err.duplicate.case.label=duplicate case label
compiler.err.duplicate.class=duplicate class: {0}
compiler.err.duplicate.default.label=duplicate default label
compiler.err.else.without.if=''else'' without ''if''
compiler.err.empty.char.lit=empty character literal
compiler.err.encl.class.required=an enclosing instance that contains {0} is required
compiler.err.enum.annotation.must.be.enum.constant=an enum annotation value must be an enum constant
compiler.err.enum.as.identifier=as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n(use -source 1.4 or lower to use ''enum'' as an identifier)
compiler.err.enum.cant.be.instantiated=enum types may not be instantiated
compiler.err.enum.label.must.be.unqualified.enum=an enum switch case label must be the unqualified name of an enumeration constant
compiler.err.enum.no.finalize=enums cannot have finalize methods
compiler.err.enum.no.subclassing=classes cannot directly extend java.lang.Enum
compiler.err.enum.types.not.extensible=enum types are not extensible
compiler.err.enums.must.be.static=enum declarations allowed only in static contexts
compiler.err.enums.not.supported.in.source=enums are not supported in -source {0}\n(use -source 5 or higher to enable enums)
compiler.err.error=error:
compiler.err.error.reading.file=error reading {0}; {1}
compiler.err.except.already.caught=exception {0} has already been caught
compiler.err.except.never.thrown.in.try=exception {0} is never thrown in body of corresponding try statement
compiler.err.expected={0} expected
compiler.err.expected2={0} or {1} expected
compiler.err.expected3={0}, {1}, or {2} expected
compiler.err.final.parameter.may.not.be.assigned=final parameter {0} may not be assigned
compiler.err.finally.without.try=''finally'' without ''try''
compiler.err.foreach.not.applicable.to.type=for-each not applicable to expression type\nrequired: {1}\nfound:    {0}
compiler.err.foreach.not.supported.in.source=for-each loops are not supported in -source {0}\n(use -source 5 or higher to enable for-each loops)
compiler.err.fp.number.too.large=floating point number too large
compiler.err.fp.number.too.small=floating point number too small
compiler.err.generic.array.creation=generic array creation
compiler.err.generic.throwable=a generic class may not extend java.lang.Throwable
compiler.err.generics.not.supported.in.source=generics are not supported in -source {0}\n(use -source 5 or higher to enable generics)
compiler.err.icls.cant.have.static.decl=Illegal static declaration in inner class {0}\nmodifier ''static'' is only allowed in constant variable declarations
compiler.err.illegal.char=illegal character: \\{0}
compiler.err.illegal.char.for.encoding=unmappable character for encoding {0}
compiler.err.illegal.combination.of.modifiers=illegal combination of modifiers: {0} and {1}
compiler.err.illegal.enum.static.ref=illegal reference to static field from initializer
compiler.err.illegal.esc.char=illegal escape character
compiler.err.illegal.forward.ref=illegal forward reference
compiler.err.illegal.generic.type.for.instof=illegal generic type for instanceof
compiler.err.illegal.initializer.for.type=illegal initializer for {0}
compiler.err.illegal.line.end.in.char.lit=illegal line end in character literal
compiler.err.illegal.nonascii.digit=illegal non-ASCII digit
compiler.err.illegal.qual.not.icls=illegal qualifier; {0} is not an inner class
compiler.err.illegal.self.ref=self-reference in initializer
compiler.err.illegal.start.of.expr=illegal start of expression
compiler.err.illegal.start.of.type=illegal start of type
compiler.err.illegal.underscore=illegal underscore
compiler.err.illegal.unicode.esc=illegal unicode escape
compiler.err.import.requires.canonical=import requires canonical name for {0}
compiler.err.improperly.formed.type.inner.raw.param=improperly formed type, type arguments given on a raw type
compiler.err.improperly.formed.type.param.missing=improperly formed type, some parameters are missing
compiler.err.incomparable.types=incomparable types: {0} and {1}
compiler.err.initializer.must.be.able.to.complete.normally=initializer must be able to complete normally
compiler.err.int.number.too.large=integer number too large: {0}
compiler.err.internal.error.cant.instantiate=internal error; cannot instantiate {0} at {1} to ({2})
compiler.err.intf.annotation.cant.have.type.params=@interface may not have type parameters
compiler.err.intf.annotation.member.clash=@interface member clashes with method ''{0}'' in {1}
compiler.err.intf.annotation.members.cant.have.params=@interface members may not have parameters
compiler.err.intf.annotation.members.cant.have.type.params=@interface members may not have type parameters
compiler.err.intf.expected.here=interface expected here
compiler.err.intf.meth.cant.have.body=interface methods cannot have body
compiler.err.intf.not.allowed.here=interface not allowed here
compiler.err.invalid.annotation.member.type=invalid type for annotation member
compiler.err.invalid.binary.number=binary numbers must contain at least one binary digit
compiler.err.invalid.hex.number=hexadecimal numbers must contain at least one hexadecimal digit
compiler.err.invalid.inferred.types=invalid inferred types for {0}; {1}
compiler.err.invalid.meth.decl.ret.type.req=invalid method declaration; return type required
compiler.err.io.exception=error reading source file: {0}
compiler.err.label.already.in.use=label {0} already in use
compiler.err.limit.code=code too large
compiler.err.limit.code.too.large.for.try.stmt=code too large for try statement
compiler.err.limit.dimensions=array type has too many dimensions
compiler.err.limit.locals=too many local variables
compiler.err.limit.parameters=too many parameters
compiler.err.limit.pool=too many constants
compiler.err.limit.pool.in.class=too many constants in class {0}
compiler.err.limit.stack=code requires too much stack
compiler.err.limit.string=constant string too long
compiler.err.limit.string.overflow=UTF8 representation for string \"{0}...\" is too long for the constant pool
compiler.err.local.enum=enum types must not be local
compiler.err.local.var.accessed.from.icls.needs.final=local variable {0} is accessed from within inner class; needs to be declared final
compiler.err.malformed.fp.lit=malformed floating point literal
compiler.err.method.does.not.override.superclass=method does not override or implement a method from a supertype
compiler.err.missing.meth.body.or.decl.abstract=missing method body, or declare abstract
compiler.err.missing.ret.stmt=missing return statement
compiler.err.missing.ret.val=missing return value
compiler.err.mod.not.allowed.here=modifier {0} not allowed here
compiler.err.multicatch.not.supported.in.source=multi-catch statement is not supported in -source {0}\n(use -source 7 or higher to enable multi-catch statement)
compiler.err.multicatch.parameter.may.not.be.assigned=multi-catch parameter {0} may not be assigned
compiler.err.multicatch.types.must.be.disjoint=Alternatives in a multi-catch statement cannot be related by subclassing\nAlternative {0} is a subclass of alternative {1}
compiler.err.name.clash.same.erasure=name clash: {0} and {1} have the same erasure
compiler.err.name.clash.same.erasure.no.hide=name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other
compiler.err.name.clash.same.erasure.no.override=name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither overrides the other
compiler.err.name.clash.same.erasure.no.override.1=name clash: {0} in {1} overrides a method whose erasure is the same as another method, yet neither overrides the other\nfirst method:  {2} in {3}\nsecond method: {4} in {5}
compiler.err.name.reserved.for.internal.use={0} is reserved for internal use
compiler.err.native.meth.cant.have.body=native methods cannot have a body
compiler.err.neither.conditional.subtype=incompatible types for ?: neither is a subtype of the other\nsecond operand: {0}\nthird operand : {1}
compiler.err.new.not.allowed.in.annotation=''new'' not allowed in an annotation
compiler.err.no.annotation.member=no annotation member {0} in {1}
compiler.err.no.encl.instance.of.type.in.scope=no enclosing instance of type {0} is in scope
compiler.err.no.intf.expected.here=no interface expected here
compiler.err.no.match.entry={0} has no match in entry in {1}; required {2}
compiler.err.no.superclass={0} has no superclass
compiler.err.non-static.cant.be.ref=non-static {0} {1} cannot be referenced from a static context
compiler.err.not.annotation.type={0} is not an annotation type
compiler.err.not.def.access.class.intf.cant.access={0} in {1} is defined in an inaccessible class or interface
compiler.err.not.def.public.cant.access={0} is not public in {1}; cannot be accessed from outside package
compiler.err.not.encl.class=not an enclosing class: {0}
compiler.err.not.loop.label=not a loop label: {0}
compiler.err.not.stmt=not a statement
compiler.err.not.within.bounds=type argument {0} is not within bounds of type-variable {1}
compiler.err.operator.cant.be.applied=bad operand type {1} for unary operator ''{0}''
compiler.err.operator.cant.be.applied.1=bad operand types for binary operator ''{0}''\nfirst type:  {1}\nsecond type: {2}
compiler.err.orphaned=orphaned {0}
compiler.err.override.incompatible.ret={0}\nreturn type {1} is not compatible with {2}
compiler.err.override.meth={0}\noverridden method is {1}
compiler.err.override.meth.doesnt.throw={0}\noverridden method does not throw {1}
compiler.err.override.static={0}\noverriding method is static
compiler.err.override.weaker.access={0}\nattempting to assign weaker access privileges; was {1}
compiler.err.pkg.annotations.sb.in.package-info.java=package annotations should be in file package-info.java
compiler.err.pkg.clashes.with.class.of.same.name=package {0} clashes with class of same name
compiler.err.premature.eof=reached end of file while parsing
compiler.err.prob.found.req={0}\nrequired: {2}\nfound:    {1}
compiler.err.prob.found.req.1={0} {3}\nrequired: {2}\nfound:    {1}
compiler.err.proc.bad.config.file=Bad service configuration file, or exception thrown while constructing Processor object: {0}
compiler.err.proc.cant.access=cannot access {0}\n{1}\nConsult the following stack trace for details.\n{2}
compiler.err.proc.cant.access.1=cannot access {0}\n{1}
compiler.err.proc.cant.create.loader=Could not create class loader for annotation processors: {0}
compiler.err.proc.cant.find.class=Could not find class file for ''{0}''.
compiler.err.proc.messager={0}
compiler.err.proc.no.explicit.annotation.processing.requested=Class names, ''{0}'', are only accepted if annotation processing is explicitly requested
compiler.err.proc.no.service=A service loader class could not be found.\nEither java.util.ServiceLoader or sun.misc.Service must be available.
compiler.err.proc.processor.bad.option.name=Bad option name ''{0}'' provided by processor ''{1}''
compiler.err.proc.processor.cant.instantiate=Could not instantiate an instance of processor ''{0}''
compiler.err.proc.processor.constructor.error=Exception thrown while constructing Processor object: {0}
compiler.err.proc.processor.not.found=Annotation processor ''{0}'' not found
compiler.err.proc.processor.wrong.type=Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor
compiler.err.proc.service.problem=Error creating a service loader to load Processors.
compiler.err.qualified.new.of.static.class=qualified new of static class
compiler.err.recursive.ctor.invocation=recursive constructor invocation
compiler.err.ref.ambiguous=reference to {0} is ambiguous, both {1} {2} in {3} and {4} {5} in {6} match
compiler.err.repeated.annotation.target=repeated annotation target
compiler.err.repeated.interface=repeated interface
compiler.err.repeated.modifier=repeated modifier
compiler.err.report.access={0} has {1} access in {2}
compiler.err.ret.outside.meth=return outside method
compiler.err.signature.doesnt.match.intf=signature does not match {0}; incompatible interfaces
compiler.err.signature.doesnt.match.supertype=signature does not match {0}; incompatible supertype
compiler.err.source.cant.overwrite.input.file=error writing source; cannot overwrite input file {0}
compiler.err.stack.sim.error=Internal error: stack sim error on {0}
compiler.err.static.imp.only.classes.and.interfaces=static import only from classes and interfaces
compiler.err.static.import.not.supported.in.source=static import declarations are not supported in -source {0}\n(use -source 5 or higher to enable static import declarations)
compiler.err.string.const.req=constant string expression required
compiler.err.string.switch.not.supported.in.source=strings in switch are not supported in -source {0}\n(use -source 7 or higher to enable strings in switch)
compiler.err.synthetic.name.conflict=the symbol {0} conflicts with a compiler-synthesized symbol in {1}
compiler.err.throws.not.allowed.in.intf.annotation=throws clause not allowed in @interface members
compiler.err.try.resource.may.not.be.assigned=auto-closeable resource {0} may not be assigned
compiler.err.try.with.resources.not.supported.in.source=try-with-resources is not supported in -source {0}\n(use -source 7 or higher to enable try-with-resources)
compiler.err.try.without.catch.finally.or.resource.decls=''try'' without ''catch'', ''finally'' or resource declarations
compiler.err.try.without.catch.or.finally=''try'' without ''catch'' or ''finally''
compiler.err.type.doesnt.take.params=type {0} does not take parameters
compiler.err.type.found.req=unexpected type\nrequired: {1}\nfound:    {0}
compiler.err.type.var.cant.be.deref=cannot select from a type variable
compiler.err.type.var.may.not.be.followed.by.other.bounds=a type variable may not be followed by other bounds
compiler.err.type.var.more.than.once=type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
compiler.err.type.var.more.than.once.in.result=type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
compiler.err.types.incompatible.diff.ret=types {0} and {1} are incompatible; both define {2}, but with unrelated return types
compiler.err.unclosed.char.lit=unclosed character literal
compiler.err.unclosed.comment=unclosed comment
compiler.err.unclosed.str.lit=unclosed string literal
compiler.err.undef.label=undefined label: {0}
compiler.err.undetermined.type=cannot infer type arguments for {0}
compiler.err.undetermined.type.1=cannot infer type arguments for {0};\nreason: {1}
compiler.err.unexpected.type=unexpected type\nrequired: {0}\nfound:    {1}
compiler.err.unreachable.stmt=unreachable statement
compiler.err.unreported.exception.default.constructor=unreported exception {0} in default constructor
compiler.err.unreported.exception.implicit.close=unreported exception {0}; must be caught or declared to be thrown\nexception thrown from implicit call to close() on resource variable ''{1}''
compiler.err.unreported.exception.need.to.catch.or.throw=unreported exception {0}; must be caught or declared to be thrown
compiler.err.unsupported.binary.lit=binary literals are not supported in -source {0}\n(use -source 7 or higher to enable binary literals)
compiler.err.unsupported.cross.fp.lit=hexadecimal floating-point literals are not supported on this VM
compiler.err.unsupported.encoding=unsupported encoding: {0}
compiler.err.unsupported.fp.lit=hexadecimal floating point literals are not supported in -source {0}\n(use -source 5 or higher to enable hexadecimal floating point literals)
compiler.err.unsupported.underscore.lit=underscores in literals are not supported in -source {0}\n(use -source 7 or higher to enable underscores in literals)
compiler.err.var.might.already.be.assigned=variable {0} might already have been assigned
compiler.err.var.might.be.assigned.in.loop=variable {0} might be assigned in loop
compiler.err.var.might.not.have.been.initialized=variable {0} might not have been initialized
compiler.err.varargs.and.old.array.syntax=legacy array notation not allowed on variable-arity parameter
compiler.err.varargs.invalid.trustme.anno=Invalid {0} annotation. {1}
compiler.err.varargs.not.supported.in.source=variable-arity methods are not supported in -source {0}\n(use -source 5 or higher to enable variable-arity methods)
compiler.err.void.not.allowed.here=''void'' type not allowed here
compiler.err.warnings.and.werror=warnings found and -Werror specified
compiler.err.wrong.number.type.args=wrong number of type arguments; required {0}
compiler.err.wrong.target.for.polymorphic.signature.definition=MethodHandle API building requires -target 7 runtimes or better; current is -target {0}
compiler.misc.anonymous.class=<anonymous {0}>
compiler.misc.arg.length.mismatch=actual and formal argument lists differ in length
compiler.misc.assignment.from.super-bound=assignment from super-bound type {0}
compiler.misc.assignment.to.extends-bound=assignment to extends-bound type {0}
compiler.misc.bad.class.file.header=bad class file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the classpath.
compiler.misc.bad.class.signature=bad class signature: {0}
compiler.misc.bad.const.pool.tag=bad constant pool tag: {0}
compiler.misc.bad.const.pool.tag.at=bad constant pool tag: {0} at {1}
compiler.misc.bad.enclosing.class=bad enclosing class for {0}: {1}
compiler.misc.bad.enclosing.method=bad enclosing method attribute for class {0}
compiler.misc.bad.runtime.invisible.param.annotations=bad RuntimeInvisibleParameterAnnotations attribute: {0}
compiler.misc.bad.signature=bad signature: {0}
compiler.misc.bad.source.file.header=bad source file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the sourcepath.
compiler.misc.base.membership=all your base class are belong to us
compiler.misc.cant.implement={0} in {1} cannot implement {2} in {3}
compiler.misc.cant.override={0} in {1} cannot override {2} in {3}
compiler.misc.captured.type=CAP#{0}
compiler.misc.ccf.found.later.version=class file has later version than expected: {0}
compiler.misc.ccf.unrecognized.attribute=unrecognized attribute: {0}
compiler.misc.clashes.with={0} in {1} clashes with {2} in {3}
compiler.misc.class.file.not.found=class file for {0} not found
compiler.misc.class.file.wrong.class=class file contains wrong class: {0}
compiler.misc.count.error={0} error
compiler.misc.count.error.plural={0} errors
compiler.misc.count.warn={0} warning
compiler.misc.count.warn.plural={0} warnings
compiler.misc.diamond={0}<>
compiler.misc.diamond.and.anon.class=cannot use ''<>'' with anonymous inner classes
compiler.misc.diamond.and.explicit.params=cannot use ''<>'' with explicit type parameters for constructor
compiler.misc.diamond.non.generic=cannot use ''<>'' with non-generic class {0}
compiler.misc.explicit.param.do.not.conform.to.bounds=explicit type argument {0} does not conform to declared bound(s) {1}
compiler.misc.fatal.err.cant.close.loader=Fatal Error: Cannot close class loader for annotation processors
compiler.misc.fatal.err.cant.locate.ctor=Fatal Error: Unable to find constructor for {0}
compiler.misc.fatal.err.cant.locate.field=Fatal Error: Unable to find field {0}
compiler.misc.fatal.err.cant.locate.meth=Fatal Error: Unable to find method {0}
compiler.misc.fatal.err.no.java.lang=Fatal Error: Unable to find package java.lang in classpath or bootclasspath
compiler.misc.file.does.not.contain.package=file does not contain package {0}
compiler.misc.file.doesnt.contain.class=file does not contain class {0}
compiler.misc.illegal.start.of.class.file=illegal start of class file
compiler.misc.inaccessible.varargs.type=formal varargs element type {0} is not accessible from {1} {2}
compiler.misc.inapplicable.method={0} {1}.{2} is not applicable\n({3})
compiler.misc.incompatible.types=incompatible types
compiler.misc.incompatible.types.1=incompatible types; {0}
compiler.misc.incompatible.upper.bounds=inference variable {0} has incompatible upper bounds {1}
compiler.misc.inconvertible.types=inconvertible types
compiler.misc.infer.arg.length.mismatch=cannot instantiate from arguments because actual and formal argument lists differ in length
compiler.misc.infer.no.conforming.assignment.exists=no instance(s) of type variable(s) {0} exist so that argument type {1} conforms to formal parameter type {2}
compiler.misc.infer.no.conforming.instance.exists=no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
compiler.misc.inferred.do.not.conform.to.bounds=inferred type does not conform to declared bound(s)\ninferred: {0}\nbound(s): {1}
compiler.misc.intersection.type=INT#{0}
compiler.misc.kindname.annotation=@interface
compiler.misc.kindname.class=class
compiler.misc.kindname.constructor=constructor
compiler.misc.kindname.enum=enum
compiler.misc.kindname.instance.init=instance initializer
compiler.misc.kindname.interface=interface
compiler.misc.kindname.method=method
compiler.misc.kindname.package=package
compiler.misc.kindname.static=static
compiler.misc.kindname.static.init=static initializer
compiler.misc.kindname.type.variable=type variable
compiler.misc.kindname.type.variable.bound=bound of type variable
compiler.misc.kindname.value=value
compiler.misc.kindname.variable=variable
compiler.misc.location={0} {1}
compiler.misc.location.1={0} {1} of type {2}
compiler.misc.no.args=no arguments
compiler.misc.no.conforming.assignment.exists=actual argument {0} cannot be converted to {1} by method invocation conversion
compiler.misc.no.unique.maximal.instance.exists=no unique maximal instance exists for type variable {0} with upper bounds {1}
compiler.misc.no.unique.minimal.instance.exists=no unique minimal instance exists for type variable {0} with lower bounds {1}
compiler.misc.possible.loss.of.precision=possible loss of precision
compiler.misc.resume.abort=R)esume, A)bort>
compiler.misc.source.unavailable=(source unavailable)
compiler.misc.token.bad-symbol=<bad symbol>
compiler.misc.token.character=<character>
compiler.misc.token.double=<double>
compiler.misc.token.end-of-input=<end of input>
compiler.misc.token.float=<float>
compiler.misc.token.identifier=<identifier>
compiler.misc.token.integer=<integer>
compiler.misc.token.long-integer=<long integer>
compiler.misc.token.string=<string>
compiler.misc.try.not.applicable.to.type=try-with-resources not applicable to variable type
compiler.misc.type.captureof=capture#{0} of {1}
compiler.misc.type.captureof.1=capture#{0}
compiler.misc.type.none=<none>
compiler.misc.type.null=<null>
compiler.misc.type.parameter=type parameter {0}
compiler.misc.type.req.array.or.iterable=array or java.lang.Iterable
compiler.misc.type.req.class=class
compiler.misc.type.req.class.array=class or array
compiler.misc.type.req.exact=class or interface without bounds
compiler.misc.type.req.ref=reference
compiler.misc.type.var={0}#{1}
compiler.misc.type.variable.has.undetermined.type=type variable {0} has undetermined type
compiler.misc.unable.to.access.file=unable to access file: {0}
compiler.misc.unchecked.assign=unchecked conversion
compiler.misc.unchecked.cast.to.type=unchecked cast
compiler.misc.unchecked.clash.with={0} in {1} overrides {2} in {3}
compiler.misc.unchecked.implement={0} in {1} implements {2} in {3}
compiler.misc.unchecked.override={0} in {1} overrides {2} in {3}
compiler.misc.undecl.type.var=undeclared type variable: {0}
compiler.misc.undetermined.type=undetermined type
compiler.misc.unicode.str.not.supported=unicode string in class file not supported
compiler.misc.unnamed.package=unnamed package
compiler.misc.varargs.argument.mismatch=argument type {0} does not conform to vararg element type {1}
compiler.misc.varargs.clash.with={0} in {1} overrides {2} in {3}
compiler.misc.varargs.implement={0} in {1} implements {2} in {3}
compiler.misc.varargs.override={0} in {1} overrides {2} in {3}
compiler.misc.varargs.trustme.on.non.varargs.meth=Method {0} is not a varargs method.
compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs element type {0} is reifiable.
compiler.misc.varargs.trustme.on.virtual.varargs=Instance method {0} is not final.
compiler.misc.verbose.checking.attribution=[checking {0}]
compiler.misc.verbose.classpath=[search path for class files: {0}]
compiler.misc.verbose.loading=[loading {0}]
compiler.misc.verbose.parsing.done=[parsing completed {0}ms]
compiler.misc.verbose.parsing.started=[parsing started {0}]
compiler.misc.verbose.retro=[retrofitting {0}]
compiler.misc.verbose.retro.with=\tretrofitting {0} with {1}
compiler.misc.verbose.retro.with.list=\tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}
compiler.misc.verbose.sourcepath=[search path for source files: {0}]
compiler.misc.verbose.total=[total {0}ms]
compiler.misc.verbose.wrote.file=[wrote {0}]
compiler.misc.version.not.available=(version info not available)
compiler.misc.where.captured={0} extends {1} super: {2} from capture of {3}
compiler.misc.where.captured.1={0} extends {1} from capture of {3}
compiler.misc.where.description.captured=where {0} is a fresh type-variable:
compiler.misc.where.description.captured.1=where {0} are fresh type-variables:
compiler.misc.where.description.intersection=where {0} is an intersection type:
compiler.misc.where.description.intersection.1=where {0} are intersection types:
compiler.misc.where.description.typevar=where {0} is a type-variable:
compiler.misc.where.description.typevar.1=where {0} are type-variables:
compiler.misc.where.intersection={0} extends {1}
compiler.misc.where.typevar={0} extends {1} declared in {2} {3}
compiler.misc.where.typevar.1={0} declared in {2} {3}
compiler.misc.wrong.version=class file has wrong version {0}.{1}, should be {2}.{3}
compiler.misc.x.print.processor.info=Processor {0} matches {1} and returns {2}.
compiler.misc.x.print.rounds=Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}
compiler.note.deprecated.filename={0} uses or overrides a deprecated API.
compiler.note.deprecated.filename.additional={0} has additional uses or overrides of a deprecated API.
compiler.note.deprecated.plural=Some input files use or override a deprecated API.
compiler.note.deprecated.plural.additional=Some input files additionally use or override a deprecated API.
compiler.note.deprecated.recompile=Recompile with -Xlint:deprecation for details.
compiler.note.note=Note:
compiler.note.proc.messager={0}
compiler.note.sunapi.filename={0} uses internal proprietary API that may be removed in a future release.
compiler.note.sunapi.filename.additional={0} uses additional internal proprietary API that may be removed in a future release.
compiler.note.sunapi.plural=Some input files use internal proprietary API that may be removed in a future release.
compiler.note.sunapi.plural.additional=Some input files additionally use internal proprietary API that may be removed in a future release.
compiler.note.sunapi.recompile=Recompile with -Xlint:sunapi for details.
compiler.note.unchecked.filename={0} uses unchecked or unsafe operations.
compiler.note.unchecked.filename.additional={0} has additional unchecked or unsafe operations.
compiler.note.unchecked.plural=Some input files use unchecked or unsafe operations.
compiler.note.unchecked.plural.additional=Some input files additionally use unchecked or unsafe operations.
compiler.note.unchecked.recompile=Recompile with -Xlint:unchecked for details.
compiler.warn.annotation.method.not.found=Cannot find annotation method ''{1}()'' in type ''{0}''
compiler.warn.annotation.method.not.found.reason=Cannot find annotation method ''{1}()'' in type ''{0}'': {2}
compiler.warn.assert.as.identifier=as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n(use -source 1.4 or higher to use ''assert'' as a keyword)
compiler.warn.big.major.version={0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\nIt is recommended that the compiler be upgraded.
compiler.warn.constant.SVUID=serialVersionUID must be constant in class {0}
compiler.warn.diamond.redundant.args=redundant type arguments in new expression (use diamond operator instead).
compiler.warn.diamond.redundant.args.1=redundant type arguments in new expression (use diamond operator instead).\nexplicit: {0}\ninferred: {1}
compiler.warn.dir.path.element.not.found=bad path element \"{0}\": no such directory
compiler.warn.div.zero=division by zero
compiler.warn.empty.if=empty statement after if
compiler.warn.enum.as.identifier=as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n(use -source 5 or higher to use ''enum'' as a keyword)
compiler.warn.finally.cannot.complete=finally clause cannot complete normally
compiler.warn.forward.ref=reference to variable ''{0}'' before it has been initialized
compiler.warn.future.attr={0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files
compiler.warn.has.been.deprecated={0} in {1} has been deprecated
compiler.warn.illegal.char.for.encoding=unmappable character for encoding {0}
compiler.warn.improper.SVUID=serialVersionUID must be declared static final in class {0}
compiler.warn.inexact.non-varargs.call=non-varargs call of varargs method with inexact argument type for last parameter;\ncast to {0} for a varargs call\ncast to {1} for a non-varargs call and to suppress this warning
compiler.warn.invalid.archive.file=Unexpected file on path: {0}
compiler.warn.lintOption=[{0}]
compiler.warn.long.SVUID=serialVersionUID must be of type long in class {0}
compiler.warn.missing.SVUID=serializable class {0} has no definition of serialVersionUID
compiler.warn.missing.deprecated.annotation=deprecated item is not annotated with @Deprecated
compiler.warn.override.bridge={0}; overridden method is a bridge method
compiler.warn.override.unchecked.ret={0}\nreturn type requires unchecked conversion from {1} to {2}
compiler.warn.override.unchecked.thrown={0}\noverridden method does not throw {1}
compiler.warn.override.varargs.extra={0}; overriding method is missing ''...''
compiler.warn.override.varargs.missing={0}; overridden method has no ''...''
compiler.warn.path.element.not.found=bad path element \"{0}\": no such file or directory
compiler.warn.pkg-info.already.seen=a package-info.java file has already been seen for package {0}
compiler.warn.position.overflow=Position encoding overflows at line {0}
compiler.warn.possible.fall-through.into.case=possible fall-through into case
compiler.warn.prob.found.req={0}\nrequired: {2}\nfound:    {1}
compiler.warn.proc.annotations.without.processors=No processor claimed any of these annotations: {0}
compiler.warn.proc.file.create.last.round=File for type ''{0}'' created in the last round will not be subject to annotation processing.
compiler.warn.proc.file.reopening=Attempt to create a file for ''{0}'' multiple times
compiler.warn.proc.illegal.file.name=Cannot create file for illegal name ''{0}''.
compiler.warn.proc.malformed.supported.string=Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''
compiler.warn.proc.messager={0}
compiler.warn.proc.package.does.not.exist=package {0} does not exist
compiler.warn.proc.proc-only.requested.no.procs=Annotation processing without compilation requested but no processors were found.
compiler.warn.proc.processor.incompatible.source.version=Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''
compiler.warn.proc.suspicious.class.name=Creating file for a type whose name ends in {1}: ''{0}''
compiler.warn.proc.type.already.exists=A file for type ''{0}'' already exists on the sourcepath or classpath
compiler.warn.proc.type.recreate=Attempt to create a file for type ''{0}'' multiple times
compiler.warn.proc.unclosed.type.files=Unclosed files for the types ''{0}''; these types will not undergo annotation processing
compiler.warn.proc.unmatched.processor.options=The following options were not recognized by any processor: ''{0}''
compiler.warn.proc.use.implicit=Implicitly compiled files were not subject to annotation processing.\nUse -implicit to specify a policy for implicit compilation.
compiler.warn.proc.use.proc.or.implicit=Implicitly compiled files were not subject to annotation processing.\nUse -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
compiler.warn.raw.class.use=found raw type: {0}\nmissing type arguments for generic class {1}
compiler.warn.redundant.cast=redundant cast to {0}
compiler.warn.self.ref=self-reference in initializer of variable ''{0}''
compiler.warn.source.no.bootclasspath=bootstrap class path not set in conjunction with -source {0}
compiler.warn.static.not.qualified.by.type=static {0} should be qualified by type name, {1}, instead of by an expression
compiler.warn.sun.proprietary={0} is internal proprietary API and may be removed in a future release
compiler.warn.synthetic.name.conflict=the symbol {0} conflicts with a compiler-synthesized symbol in {1}
compiler.warn.try.explicit.close.call=explicit call to close() on an auto-closeable resource
compiler.warn.try.resource.not.referenced=auto-closeable resource {0} is never referenced in body of corresponding try statement
compiler.warn.try.resource.throws.interrupted.exc=auto-closeable resource {0} has a member method close() that could throw InterruptedException
compiler.warn.unchecked.assign=unchecked assignment: {0} to {1}
compiler.warn.unchecked.assign.to.var=unchecked assignment to variable {0} as member of raw type {1}
compiler.warn.unchecked.call.mbr.of.raw.type=unchecked call to {0} as a member of the raw type {1}
compiler.warn.unchecked.cast.to.type=unchecked cast to type {0}
compiler.warn.unchecked.generic.array.creation=unchecked generic array creation for varargs parameter of type {0}
compiler.warn.unchecked.meth.invocation.applied=unchecked method invocation: {0} {1} in {4} {5} is applied to given types\nrequired: {2}\nfound: {3}
compiler.warn.unchecked.varargs.non.reifiable.type=Possible heap pollution from parameterized vararg type {0}
compiler.warn.unexpected.archive.file=Unexpected extension for archive file: {0}
compiler.warn.unknown.enum.constant=unknown enum constant {1}.{2}
compiler.warn.unknown.enum.constant.reason=unknown enum constant {1}.{2}\nreason: {3}
compiler.warn.unreachable.catch=unreachable catch clause\nthrown type {0} has already been caught
compiler.warn.unreachable.catch.1=unreachable catch clause\nthrown types {0} have already been caught
compiler.warn.varargs.redundant.trustme.anno=Redundant {0} annotation. {1}
compiler.warn.varargs.unsafe.use.varargs.param=Varargs method could cause heap pollution from non-reifiable varargs parameter {0}
compiler.warn.warning=warning: